# Q.js+iTorr.js 


## 缓存机制

### JavaScript 线程

在发起请求前，首先会在当前的 JavaScript 环境下查找，是否有访问过请求的地址。如果已经访问过那么会直接在当前线程调用回调函数。

这时候所用的时间接近于立刻。

### HTTP 缓存

如果当前请求没有在 JavaScript 里记录的话，那么就会通过 XHR 发起 HTTP 请求。这部分开始是需要服务器端进行配合才有效果。
如果遇到本地浏览器加载过的资源，那么在下次加载时会提交更新时间给后端 HTTP 服务，服务器端对比更新时间、如果内容在这段时间没有发生改变那么会返回 HTTP 状态码 304 通知浏览器调用本地缓存数据。

这时候所耗时间在 HTTP 请求上。

服务器缓存

如果文件已经更新或从未请求过，那么就需要服务器发送一份新的给服务器端。对于访问量较大的相同数据 我们可以在服务端通过Memcache/radis/文件的形式对其进行缓存。如果集中缓存那么就把服务器缓存的数据返回给 HTTP 请求。

这段时间所耗时间在 HTTP 请求和读取服务器缓存上。

SQL请求

如果没有或者没有击中服务器缓存的情况，我们就要从 SQL 里面获取一份最新数据。这最后一步要尽可能避免，在复杂的SQL语句情况下所耗时间不可预计。
在SQL返回数据时，我们将返回的数据缓存到服务器缓存中，来应对之后访问这条数据的情况。

这段时间所消耗的时间在 HTTP 请求和 SQL 请求，以及对数据的预处理上。


 >在通常的文档流情况下 使用iTorrJS的ajax请求 缓存优势并不明显。


$.j $.l 优化外联 CSS 与 外联JavaScript 以及JSON-P




## Q.js&iTorrJS文档流 和 通常的文档流 对比

>Q.jS&iTorr文档流简称“Q流”，通常文档流简称“通常流”

既然是对比就要首先 统一起点 简化流程，每一条目只对比一点。

### 加载过程对比

我们先忽略其他数据，只对比加载过程。我选了三个有代表性的时段。

#### 初次加载过程对比


在初次加过过程中，Q流总数据量比通常流要少、但因为把原本杂糅在一起的 HTML 分离成了 HTML模板 和 JSON格式数据 在总时长上要比通常流久一点。

初次加载过程中，Q流总时长并无优势。

但加载是一个过程，Q流在初次加载过程中开始显示内容的时机要比通常流早很多，可以在加载完HTML模板时开始显示内容。而通常流则必须在加载完HTML后等待CSS和JS加载运行完（不包括images）才开始显示内容。在加载过程的感官上，Q流反倒更快速友好。


#### 跳页过程对比（初次访问）
对比完初次加载我们再看看从当前页跳转到另一页时的情况。
通常流依旧需要通过服务器拼合请求数据 和模板拼合然后返回数据给浏览器。和初次加载的区别在于外联 JavaScript 和 CSS 服务器会返回302 通知浏览器调用上次的缓存。会比初次加载略快，但HTML加载过程中的白屏依旧不可避。

Q流这时不太一样咯~ JavaScript和CSS的加载过程消失了！仅剩下取数据的JSON，因为纯数据和不需要服务器预处理以及拼模板，会节省HTTP和服务器开销、在总时间上快于通常流。并且没有白屏过程！这时候JavaScript依旧可以做各种各样的事情。

其实不止如此，对于很大几率被访问的页面、我们可以在首次加载完成之后，找空闲时间提前预载可能需要的数据。这样加载过程就会变成下图这样

##### 跳页过程对比（非初次访问）
在访问打开过的页面时，结果又完全不一样了。Q流的加载过程变成了不及2ms OAQ 
通常流这时因为调用的是php文件，缓存机制无法工作 和初次访问的结果是一样的、HTML又重新算了一遍…

回到缓存那一段的结尾

 >在通常的文档流情况下 使用iTorrJS的ajax请求 缓存优势并不明显。

 Q流的优势是在 Q.js 的单页路由和 iTorr.js 的缓存机制一起应用时才能体现的。单页让请求访问 第一层 JavaScript 缓存的情况越多，Q流的优势就越明显。
 但其实优势远不止这些~


 